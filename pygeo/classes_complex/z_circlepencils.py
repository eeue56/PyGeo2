import pygeo.base.abstract_elements_complex as Complex
import pygeo.base.abstract_elements_usphere as USphere
from pygeo.base.abstract_elements_real import method_get
from pygeo.base.pygeoexceptions import Argument_Type_Error

from pygeo.base.pygeomath import *
from pygeo.base.pygeoconstants import *
from pygeo.base.pygeoopts import *

import cmath


zPencilClasses = ['zCircles','u_to_zCirclePencil']

zPencilDef = ['zCirclePencil']


__all__ = zPencilClasses + zPencilDef

class zCircles(Complex._zCirclePencil):
   """
:constructors: 

     - zCirclePencil(zcircle1,zcircle2)
     - zCircles(zcircle1,zcircle2)

:returns: pencil of `complex circle`_ s generated by the given `complex circle`_ s,
          and through the points of intersection of the circles of the generators
          if the intersection exists (i.e. the pencil is hyperbolic)

:site ref: http://en.wikipedia.org/wiki/User:Pmurray_bigpond.com/Geometry_of_Complex_Numbers
   """
   def __init__(self,circle1,circle2,**kws):
      Complex._zCirclePencil.__init__(self,*[circle1,circle2],**kws)
      self.circle1=circle1
      self.circle2=circle2
      self.update()

   def _findSelf(self):
      for i,zcircle  in enumerate(self.zcircles):
         zcircle._hermitian=self.circle1._hermitian*i+self.circle2._hermitian*(self.density-i)
         zcircle.set_radius_from_hermitian()
      return True

class u_to_zCirclePencil(Complex._zCirclePencil):
   """
:constructors: 

     - zCirclePencil(u_circlepencil)
     - u_to_zcirclePencil(u_circlepencil)
     
:returns: pencil of circles (inclusive of lines) on the `complex plane`_
          generated by the `stereographic projection`_
          of a pencil of `spheric sections`_ of the `Riemann sphere`_

:site ref: http://www.uwgb.edu/dutchs/STRUCTGE/stereo1.htm
   """

   def __init__(self,r_pencil,**kw):
      Complex._zCirclePencil.__init__(self,*[r_pencil],**kw)
      self.density=r_pencil.density
      self.r_pencil=r_pencil
      self.update()

   def _findSelf(self):
      for i,zcircle in enumerate(self.zcircles):
         c_center=self.r_pencil.circles[i]._center
         d=mag(c_center)
         try:
            u=norm(c_center)
         except ZeroDivisionError:
            u=vector(0,0,0)
         a=u.x
         b=u.y
         c=u.z
         A=(d-c)*.5
         B=(a-b*complex(0,1))*.5
         C=B.conjugate()
         D=(d+c)*.5
         zcircle._hermitian=Hermitian([[A,B],[C,D]])
         zcircle.set_radius_from_hermitian()
      return True

def zCirclePencil(*args,**kws):
   """
:constructors: 

   - zCirclePencil(zcircle1,zcircle2); calls: `class zCircles`_
   - zCirclePencil(u_circlepencil); calls: `class u_to_zCirclePencil`_
   
:returns: An instance of an object derived from the `_zCirclePencil`_ abstract class,
          representing an array of `complex circles` with determined positions 
          on the `complex plane`_
   """
   __sigs__=[[Complex._zCircle,Complex._zCircle],
               [USphere._uCirclePencil]]
   t,i = method_get(__sigs__,args)
   if t is None:
      raise Argument_Type_Error(__sigs__,args)
   else:
      if i==0:
         return zCircles(t[0],t[1],**kws)
      elif i==1:
         return u_to_zCirclePencil(t[0],**kws)
      else:
         raise Argument_Type_Error(__sigs__,args)
